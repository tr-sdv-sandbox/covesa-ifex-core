// Generated from backend_transport_service.ifex by covesa-ifex-core
// DO NOT EDIT - regenerate with: ./generate_proto.sh
syntax = "proto3";



package swdv.backend_transport_service;

// Namespace: transport
// Backend transport operations

// Transport connection state
enum connection_state_t {
  UNKNOWN = 0;
  CONNECTED = 1;
  DISCONNECTED = 2;
  CONNECTING = 3;
  RECONNECTING = 4;
}

// Result of publish operation. Since publish is non-blocking and messages queue during disconnect, only queue acceptance errors are reported here. Delivery failures are indicated by gaps in on_ack sequences.

enum publish_status_t {
  OK = 0;
  QUEUE_FULL = 1;
  MESSAGE_TOO_LONG = 2;
  INVALID_REQUEST = 3;
}

// Queue fill level for adaptive throttling. Returned in publish response and broadcast via on_queue_status_changed for bidirectional feedback.

enum queue_level_t {
  EMPTY = 0;
  LOW = 1;
  NORMAL = 2;
  HIGH = 3;
  CRITICAL = 4;
  FULL = 5;
}

// Reason for connection state change
enum disconnect_reason_t {
  NONE = 0;
  REQUESTED = 1;
  NETWORK_ERROR = 2;
  BROKER_UNAVAILABLE = 3;
  AUTHENTICATION_FAILED = 4;
  PROTOCOL_ERROR = 5;
  TLS_ERROR = 6;
}

// Message persistence level (all levels preserve ordering)
enum persistence_t {
  BEST_EFFORT = 0;
  VOLATILE = 1;
  DURABLE = 2;
}

// Request to publish data to cloud. Content ID is implicit in the channel/handle - apps cannot accidentally publish to wrong topic.

message publish_request_t {
  bytes payload = 1;
  persistence_t persistence = 2;
}

// Result of publish operation (returned immediately, non-blocking)
message publish_response_t {
  uint64 sequence = 1;
  publish_status_t status = 2;
  queue_level_t queue_level = 3;
}

// Delivery confirmation for a successfully sent message. Only emitted for successful deliveries; gaps in sequence numbers indicate failures.

message delivery_ack_t {
  uint64 sequence = 1;
}

// Current connection status
message connection_status_t {
  connection_state_t state = 1;
  disconnect_reason_t reason = 2;
  sint64 timestamp_ns = 3;
}

// Outbound queue status for adaptive throttling. Broadcast via on_queue_status_changed when level changes, enabling clients to resume sending after queue drains.

message queue_status_t {
  queue_level_t level = 1;
  uint32 queue_size = 2;
  uint32 queue_capacity = 3;
}

// Transport statistics
message transport_stats_t {
  uint64 messages_sent = 1;
  uint64 messages_failed = 2;
  uint64 bytes_sent = 3;
  uint64 messages_received = 4;
  uint64 bytes_received = 5;
  sint64 last_send_timestamp_ns = 6;
  sint64 last_receive_timestamp_ns = 7;
}

// Incoming message from cloud (c2v). Content ID is implicit in the channel/handle this message arrives on.

message content_message_t {
  bytes payload = 1;
}

// Method: publish
// Queue message for cloud delivery (v2c)
message publish_request {
  publish_request_t request = 1;
}

message publish_response {
  publish_response_t result = 1;
}

service publish_service {
  rpc publish(publish_request) returns (publish_response);
}

// Method: get_connection_status
// Get current connection status
message get_connection_status_request {
}

message get_connection_status_response {
  connection_status_t status = 1;
}

service get_connection_status_service {
  rpc get_connection_status(get_connection_status_request) returns (get_connection_status_response);
}

// Method: get_queue_status
// Get outbound queue status
message get_queue_status_request {
}

message get_queue_status_response {
  queue_status_t status = 1;
}

service get_queue_status_service {
  rpc get_queue_status(get_queue_status_request) returns (get_queue_status_response);
}

// Method: get_stats
// Get transport statistics
message get_stats_request {
}

message get_stats_response {
  transport_stats_t stats = 1;
}

service get_stats_service {
  rpc get_stats(get_stats_request) returns (get_stats_response);
}

// Method: healthy
// Check if transport is ready
message healthy_request {
}

message healthy_response {
  bool is_healthy = 1;
}

service healthy_service {
  rpc healthy(healthy_request) returns (healthy_response);
}

// Method: get_content_id
// Get the content ID this channel is bound to. Useful for logging or when the app needs to know its assigned content ID.

message get_content_id_request {
}

message get_content_id_response {
  uint32 content_id = 1;
}

service get_content_id_service {
  rpc get_content_id(get_content_id_request) returns (get_content_id_response);
}

// Event: on_content
// Incoming content from cloud (c2v) for this channel's content ID.

message on_content {
  content_message_t message = 1;
}

message on_content_subscribe_request {
}

service on_content_service {
  // Server-streaming RPC for event subscription
  rpc subscribe(on_content_subscribe_request) returns (stream on_content);
}

// Event: on_ack
// Delivery confirmation stream for this channel. Only successful deliveries generate acks. Messages are sent in FIFO order, so receiving an ack for sequence N confirms that all prior sequences have completed. Gaps in acked sequence numbers indicate messages that failed to deliver.

message on_ack {
  delivery_ack_t ack = 1;
}

message on_ack_subscribe_request {
}

service on_ack_service {
  // Server-streaming RPC for event subscription
  rpc subscribe(on_ack_subscribe_request) returns (stream on_ack);
}

// Event: on_connection_changed
// Connection status changed
message on_connection_changed {
  connection_status_t status = 1;
}

message on_connection_changed_subscribe_request {
}

service on_connection_changed_service {
  // Server-streaming RPC for event subscription
  rpc subscribe(on_connection_changed_subscribe_request) returns (stream on_connection_changed);
}

// Event: on_queue_status_changed
// Queue level changed. Subscribe to receive feedback when queue drains, enabling adaptive throttling. Example: pause logs when level >= HIGH, resume when level drops to LOW.

message on_queue_status_changed {
  queue_status_t status = 1;
}

message on_queue_status_changed_subscribe_request {
}

service on_queue_status_changed_service {
  // Server-streaming RPC for event subscription
  rpc subscribe(on_queue_status_changed_subscribe_request) returns (stream on_queue_status_changed);
}


